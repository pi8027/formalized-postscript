\documentclass[a4paper, 10pt, twocolumn, titlepage]{ujarticle}

\usepackage{color}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{stmaryrd}
\usepackage{design}
\usepackage{atbegshi}
\AtBeginShipoutFirst{\special{pdf:tounicode UTF8-UCS2}}
\usepackage[dvipdfm,
    pdfauthor={坂口和彦},
    pdftitle={定理証明器CoqによるPostScriptプログラミング},
    pdfsubject={定理証明器CoqによるPostScriptプログラミング},
    pdfkeywords={Coq; SSReflect; PostScript}]{hyperref}

\definecolor{code-background}{gray}{0.8}

\lstdefinestyle{plain}{
  basicstyle=\small\tt,
  keywordstyle=,
  identifierstyle=,
  commentstyle=,
  stringstyle=,
  emphstyle=,
  backgroundcolor=\color{code-background},
  language=,
  frame=trbl,
  rulecolor=\color{white},
  numbers=none,
  numberstyle=,
  xleftmargin=0.2zw,
  xrightmargin=0.2zw,
  basewidth=0.42em,
  lineskip=-0.2ex
}

\renewcommand{\lstlistingname}{リスト}

%\renewcommand{\_}{\symbol{"5F}}
\renewcommand{\{}{\symbol{"7B}}
\renewcommand{\}}{\symbol{"7D}}

\newlength{\lengthwithlength}
\newcommand{\bnfvert}
    {\settowidth{\lengthwithlength}{::=}\mathrel{\makebox[\lengthwithlength][c]{$|$}}}
\newcommand{\bnfcce}{\mathrel{::=}}

\title{情報特別演習II最終レポート\\定理証明器CoqによるPostScriptプログラミング}
\author{情報学群情報科学類 B2 坂口和彦}
\date{2013年1月22日}

\begin{document}

\clearpage

\maketitle

\section{概要}

現在使われている一般的なプログラミング言語、環境ではプログラムの実行途中の状態を明示的に扱うことはで
きず、プログラムを記述する人がプログラムの実行中のそれぞれの部分で満たすべき性質を満たせるように十分
注意しなければならない。本演習ではこの問題を解消するため、プログラムの実行中の状態を明示的に扱えるプ
ログラミング環境を開発した。開発したプログラミング環境が対象とする言語はPostScriptという既存のプログ
ラミング言語のサブセットであり、実装は主に定理証明器SSReflect-Coqで記述した。

開発したソフトウェアは単に便利なプログラミング環境というだけではなく、記述した仕様を必ず満たすことが
保証される。また、ある範囲の自明なプログラムの自動生成、記述したプログラムのPostScriptプログラムへの
変換、埋め込みなどをサポートし、ブール値や自然数を扱うためのライブラリを持っている。このレポートでは、
演習の内容とこのソフトウェアの詳細について述べる。

成果物のほとんど全ての部分は以下のURIで公開しているので、誰でも自由にこれを試したり変更を加えたりで
きる。

{\small\texttt{http://github.com/pi8027/formalized-postscript}}

\section{はじめに}

PostScriptはAdobe Systems社がプリンタ向けに開発したスタック指向のプログラミング言語である。
PostScriptでは計算の状態を持つ手段としてスタックを使うことができるが、スタックに保存した状態を指し示
す手段は通常であればスタックの先頭から何番目の値であるかという情報(インデックスと呼ぶこととする)を使
うことになる。例えば、PostScriptで\texttt{1 2 3}を実行した後のスタックは、トップから順に3, 2, 1が配
置されている。トップを0番とすると、2を指すインデックスは1であり、1を指すインデックスは2である。

ここで\texttt{pop}命令を実行したとすると、\texttt{pop}命令はスタックのトップの値を捨てるので、(トッ
プを除き)スタック上のそれぞれの値のインデックスは1減る。逆に4をスタックに積むと、スタック上のそれぞ
れの値のインデックスは1増える。このように、インデックスは値自体が変化していなくてもプログラムの実行
が進むと変化してしまう。また、値自体が変化していくようなプログラムを記述すれば、問題はより難しくなる。
一見これ変は数があれば何も問題は無いように見える。確かにPostScriptには変数を扱う仕組みが存在するが、
スコープの扱いに問題があり高階性を生かしたプログラムを記述する上では障害となる。これ以降の内容では変
数の無いPostScriptについて考える。ただし、標準ライブラリに含まれる命令はそのままの名前で使うものとす
る。

さらにPostScriptでは、実行時に命令列を構築してそれを実行することでメタプログラミングができる。このメ
タプログラミングの手法を使わなければ上手く抽象化できないケースも数多くあるが、それを人が正しく記述す
ることは困難である。例えば、PostScriptの標準ライブラリに含まれる\texttt{repeat}という命令を再実装す
ると、その難しさが分かる。

\texttt{repeat}命令は、スタックに自然数$n$と実行可能な値$i$がこの順で積まれている状態で実行すると、
$i$を$n$回実行する命令である。例えば、\texttt{0 10 \{dup\footnote{スタックの先頭の値を取り出し、2回
スタックに積む複製の命令。} 1 add\footnote{スタックの先頭の2つの値を取り出し、和をスタックに積む命
令}\}\footnote{\texttt{\{...\}}は命令列を表すための構文であり、命令列は1つの値として扱われる。}
{ }repeat}は0をスタックに積んだ後に\texttt{dup 1 add}を10回実行するという意味である。このプログラム
を実行すると、0から10の自然数がこの順にスタックに積まれる。実際の\texttt{repeat}命令はループの中で
\texttt{exit}命令を実行するとループから抜け出すこともできるが、\texttt{exit}命令には対応しない形の
\texttt{repeat}命令の実装方法を以下で考える。

通常のPostScriptプログラミングにおけるループは、ループのための命令を使うか、命令を\texttt{def}コマン
ドを用いて変数に代入し、自分自身をその変数名で呼び出すことで実現する。しかし、\texttt{repeat}を再実
装するのにループのための命令を使うのでは再実装の意味が無く、変数は使わないことにしたので、別の方法を
考えなければならない。ループを書くもう1つの方法は、スタックに自分自身が積まれているという仮定の元で
自分自身を呼び出して再帰する命令を記述し、それを複製して呼び出すというものである。例えば、
\texttt{\{dup exec\footnote{スタックの先頭の値を取り出して実行する命令。}\} dup exec}は\texttt{\{dup
exec\}}を複製して実行するので元の状態に戻る無限ループである。この方法を使って\texttt{0 10 \{dup 1
add\} repeat}を書き直すと、以下のようになる。

\begin{lstlisting}[style=plain]
0
{
  dup 0 eq {
    pop pop
  }{
    1 sub 2 index 1 add 3 1 roll 1 index exec
  } ifelse
} dup 10 exch exec
\end{lstlisting}

一番外側の\texttt{\{...\}}で括られた部分は、自然数$n$と自分自身と自然数$m$がこの順でスタックに積まれ
た状態で実行すると$n$から$n+m$までの自然数をこの順でスタックに積む命令である。これを$i$と呼ぶことに
する。0、$i$、10、$i$が積まれた状態で\texttt{exec}を実行しているので、0から10の値がスタックに積まれ
る。$i$の中では、まず$m$を0と比較して分岐している。$m$が0の場合は$n$だけをスタック上に残せば良いので、
\texttt{pop}を2回実行して$i$と$m$をスタックから消している。$m$が0でない場合は$m-1$と$n+1$を計算し、
スタック上の値の順番を$n$、$n+1$、$i$、$m-1$、$i$にしてから\texttt{exec}を行っている。すると$n+1$、
$i$、$m$が消化されて$n+1$から$(n+1)+(m-1)=n+m$までの自然数に置き換わるので、$n$から$n+m$までの値がス
タック上に並ぶ。詳細な説明はしないが、\texttt{sub}は減算命令、\texttt{index}は指定したインデックスの
値をスタックの先頭に複製する命令、\texttt{n m roll}はスタックの先頭の$n$個の値を先頭方向に$m$個分回
転させる命令、\texttt{exch}はスタックの先頭の2要素を入れ替える命令\footnote{命令としては\texttt{2 1
roll}と同値。}、\texttt{eq}は比較の命令、\texttt{ifelse}は条件分岐の命令である。

これを踏まえて\texttt{repeat}命令を再実装することを考える。まず、以下のコードについて考えてみる。

\begin{lstlisting}[style=plain]
{
  2 index 0 eq {
    pop pop pop
  }{
    3 2 roll 1 sub 3 1 roll 1 index exec dup exec
  } ifelse
} dup exec
\end{lstlisting}

これは一見正しい\texttt{repeat}の実装であるように見える。例えば、10と\texttt{\{(hello)
=\}}\footnote{\texttt{(...)}は文字列の構文。\texttt{=}はスタックの先頭の値を出力する。
\texttt{(hello) =}と書くと、\texttt{hello}という文字列を出力する。}を積んでからこれを実行すると、
\texttt{hello}という文字列が10回表示される。一方、2と\texttt{\{pstack\footnote{スタックに積まれた値
をスタックの先頭から順に表示する命令。}\}}を積んでからこれを実行すると、以下の出力が得られる。

\begin{lstlisting}[style=plain]
{2 index 0 eq {pop pop pop} {3 2 roll 1 sub 3 1 roll 1 index
exec dup exec} ifelse}
{pstack}
1
{2 index 0 eq {pop pop pop} {3 2 roll 1 sub 3 1 roll 1 index
exec dup exec} ifelse}
{pstack}
0
\end{lstlisting}

この出力から分かることは、\texttt{repeat}を再実装するつもりで作った上の命令は、繰り返す対象となる命
令から繰り返しを実現するために持っている状態を隠せていないということである。当然、繰り返す対象となる
命令はこの状態を書き換えて本来意図していなかった振舞いを引き起こすことも可能である。この問題を解消す
るには、最初に述べたメタプログラミングの仕組みを使わなければならない。以下が正しい実装である。

\begin{lstlisting}[style=plain]
{
  2 index 0 eq {
    pop pop pop
  }{
    [ 2 index /exec cvx 6 5 roll 1 sub
    6 4 roll dup /exec cvx ] cvx exec
  } ifelse
} dup exec
\end{lstlisting}

正しくない実装との違いは、\texttt{ifelse}による分岐の後半部分だけである。\texttt{cvx}命令はスタック
の先頭の値を実行可能形式に変換する命令、\texttt{[}はマークと呼ばれる値をスタックに積む命令、
\texttt{]}はスタックの先頭に最も近い位置に積まれたマークからスタックの先頭までの値を配列にする命令で
ある。\texttt{cvx}は元の値が名前\footnote{\texttt{/}で始まるのが名前である。}であればその名前が指す
命令に、元の値が配列であれば命令列に変換する。この仕組みを使うとスタックに積んでいた値を継続に持つこ
とができるので、正しい\texttt{repeat}の実装ができる。しかしこの方法で正しいプログラムを記述するのは
難しく、また最終的にできた正しい実装も難解なものとなっている。

これらの問題は、プログラムの実行中のそれぞれの時点での十分に一般化された状態を明示的に扱えるようにす
ることで解決できると考えられる。「十分に一般化された」というのは、例えば任意の2つの自然数の組に対し
てその和を計算する加算命令を考えているのに、1+1の場合だけ取り出して状態を考えてもあまり意味が無いと
いうことである。演習で開発したプログラミング環境では、実際にこれを実現できている。

SSReflect-Coqは定理証明器と呼ばれる種類の、計算機上でプログラムや(数学、論理学的な、もしくはプログラ
ムの性質に関する)証明を記述するためのソフトウェアである。より正確には
Coq\footnote{http://coq.inria.fr/}という定理証明器があり、
SSReflect\footnote{http://ssr.msr-inria.inria.fr/}はCoqをより便利な道具にするための拡張と数学上の問
題に特化したライブラリ群である。本演習で扱う問題ではプログラムの実行中の状態や仕様を扱うが、この種類
の問題はどこか一箇所で間違いを持ち込んでしまうと全て破綻するため、それらの操作には正しさが要求される。
SSReflect-Coqは定理証明の道具なので、正しさという点では優れていると考えてこれを採用した。

\section{言語の定義}

本演習で対象とした言語の定義について述べる。まず、命令を以下の規則で帰納的に定義した。

\begin{align*}
 i &\bnfcce  \mathit{pop} \\
   &\bnfvert \mathit{copy} \\
   &\bnfvert \mathit{swap} \\
   &\bnfvert \mathit{cons} \\
   &\bnfvert \mathit{quote} \\
   &\bnfvert \mathit{exec} \\
   &\bnfvert \mathit{push} \, i \\
   &\bnfvert \mathit{pair} \, i_1 \, i_2 \\
\end{align*}

この言語では、命令と値を区別しない。言い換えると、上で定義した集合を用いて値も命令も表現する。
PostScriptにおける通常のスタック(オペランドスタックと呼ぶ)に相当するものは、命令のリストで表現できる。
プログラムも、命令のリストで表現できる。なので、オペランドスタックを表す命令のリストと残りの実行すべ
きプログラム(継続スタックと呼ぶ)を表す命令のリストの組を状態と考え、計算を状態上の二項関係として定義
する。以下が計算の規則である。

\begin{align*}
 i_1 :: vs , \mathit{pop} :: cs           & \Mapsto vs , cs \\
 i_1 :: vs , \mathit{copy} :: cs          & \Mapsto i_1 :: i_1 :: vs , cs \\
 i_2 :: i_1 :: vs , \mathit{swap} :: cs   & \Mapsto i_1 :: i_2 :: vs, cs \\
 i_2 :: i_1 :: vs , \mathit{cons} :: cs   & \Mapsto (\mathit{pair} \, i_1 \, i_2) :: vs , cs \\
 i_1 :: vs , \mathit{quote} :: cs         & \Mapsto (\mathit{push} \, i_1) :: vs , cs \\
 i_1 :: vs , \mathit{exec} :: cs          & \Mapsto vs , i_1 :: cs \\
 vs , (\mathit{push} \, i_1) :: cs        & \Mapsto i_1 :: vs , cs \\
 vs , (\mathit{pair} \, i_1 \, i_2) :: cs & \Mapsto vs , i_1 :: i_2 :: cs \\
\end{align*}

この8つの規則は、それぞれ1つの命令に対応する実行の規則である。この規則は計算の1ステップしか表さない
ので、実際には$\Mapsto$の反射推移閉包$\Mapsto^*$を扱う。命令はそれぞれ以下の意味を持つ。

\begin{description}
 \item[$\mathit{pop}$命令] オペランドスタックの先頭を取り出し、捨てる。PostScriptの\texttt{pop}命令
	    に対応する。
 \item[$\mathit{copy}$命令] オペランドスタックの先頭を取り出し、取り出した値を2回オペランドスタック
	    にプッシュする。PostScriptの\texttt{dup}命令に対応する。
 \item[$\mathit{swap}$命令] オペランドスタックの先頭の2つの値を取り出し、元とは逆順になるようにオペ
	    ランドスタックにプッシュする。PostScriptの\texttt{exch}命令に対応する。
 \item[$\mathit{cons}$命令] オペランドスタックの先頭の2つの値を取り出し、後述の$\mathit{pair}$命令を
	    用いて組を作り、オペランドスタックにプッシュする。PostScriptの命令列\texttt{[ 3 1 roll
	    /pair cvx ] cvx]}に対応する。
 \item[$\mathit{quote}$命令] オペランドスタックの先頭を取り出し、後述の$\mathit{push}$命令を用いて値
	    を作り、オペランドスタックにプッシュする。PostScriptの命令列\texttt{[ exch ] cvx}に対応
	    する。
 \item[$\mathit{exec}$命令] オペランドスタックの先頭を取り出し、継続スタックの先頭にプッシュする。
	    PostScriptの\texttt{exec}命令に対応する。
 \item[$\mathit{push} \, i$命令] $i$をオペランドスタックにプッシュする。PostScriptの\texttt{\{ $i$
	    \}}に対応する。
 \item[$\mathit{pair} \, i_1 \, i_2$命令] $i_1$と$i_2$を継続スタックにプッシュする。PostScriptの命令
	    列\texttt{$i_1$ $i_2$}に対応する。$i_1$と$i_2$がスタックの先頭に積まれた状態からこれを実
	    行するには、\texttt{[ 3 2 roll /exec cvx 4 3 roll exec cvx ] cvx exec}を実行する。
\end{description}

言語の定義は、SSReflect-Coqでは以下のように書ける。

\begin{lstlisting}[style=plain]
Inductive inst : Set :=
  | instpop | instcopy | instswap
  | instcons | instquote | instexec
  | instpush of inst
  | instpair of inst & inst.

Notation stack := (seq inst).

Notation state := (stack * stack)%type.

Inductive eval : relation state :=
  | evalpop   : forall i vs cs,
      eval (i :: vs, instpop :: cs) (vs, cs)
  | evalcopy  : forall i vs cs,
      eval (i :: vs, instcopy :: cs) (i :: i :: vs, cs)
  | evalswap  : forall i1 i2 vs cs,
      eval (i2 :: i1 :: vs, instswap :: cs)
           (i1 :: i2 :: vs, cs)
  | evalcons  : forall i1 i2 vs cs,
      eval (i2 :: i1 :: vs, instcons :: cs)
           (instpair i1 i2 :: vs, cs)
  | evalquote : forall i vs cs,
      eval (i :: vs, instquote :: cs) (instpush i :: vs, cs)
  | evalexec  : forall i vs cs,
      eval (i :: vs, instexec :: cs) (vs, i :: cs)
  | evalpush  : forall i vs cs,
      eval (vs, instpush i :: cs) (i :: vs, cs)
  | evalpair  : forall i1 i2 vs cs,
      eval (vs, instpair i1 i2 :: cs) (vs, i1 :: i2 :: cs).

Notation evalrtc := (clos_refl_trans_1n state eval).

Infix "|=>" := eval (at level 50, no associativity).
Infix "|=>*" := evalrtc (at level 50, no associativity).
\end{lstlisting}

\section{プログラムの書き方}

次に、具体的なプログラムの書き方を説明する。最終的に落ち着いた記述方法が優れている理由を示すため、開
発の途中で辿った記述方法を時系列順に紹介する。例として、スタックの先頭にある3つの要素の順序を逆順に
する命令を構成する。

最も原始的な方法ではプログラムを直接的に命令型の値として記述し、それに証明を付けていた。プログラム自
体は以下のように記述できる。

\begin{lstlisting}[style=plain]
Definition rev3 : inst := instseqc
  [:: instquote; instswap; instquote; instcons;
    instswap; instquote; instcons; instexec].
\end{lstlisting}

\texttt{instseqc}は命令列をリストとして表現したものを対応する命令に対応付ける関数である。\texttt{[::
... ]}はSSReflectが提供しているリストの表記表である。この記述によって\texttt{rev3}という変数が
\texttt{:=}以降に書かれた値に束縛される。

これに対応する証明を書く必要がある。証明は、以下のようにして始められる。

\begin{lstlisting}[style=plain]
Goal forall i1 i2 i3 vs cs,
  (i3 :: i2 :: i1 :: vs, rev3 :: cs) |=>*
  (i1 :: i2 :: i3 :: vs, cs).
\end{lstlisting}

これは、\texttt{rev3}という命令が満たすべき性質を命題として書き表したものである。この命題の意味は
「任意の命令$i_1$、$i_2$、$i_3$と任意の命令のリスト$\mathit{vs}$、$\mathit{cs}$に関して、$(i_3 ::
i_2 :: i_1 :: \mathit{vs}, \mathit{rev3} :: \mathit{cs}) \Mapsto^* (i_1 :: i_2 :: i_3 ::
\mathit{vs}, \mathit{cs})$が成り立つ」であり、\texttt{rev3}の仕様としては妥当である。

上に示した通りの入力をすると、以下の出力が得られる。

\begin{lstlisting}[style=plain]
1 subgoals, subgoal 1 (ID 32)
  
  ============================
   forall (i1 i2 i3 : inst) (vs cs : stack),
   ([:: i3, i2, i1 & vs], rev3 :: cs)
   |=>* ([:: i1, i2, i3 & vs], cs)
\end{lstlisting}

これは、残りの証明すべき命題を表している。現時点では最初に入力した命題と全く同じである。

証明は、\texttt{Proof}コマンドによって始める。\texttt{rev3}を展開して証明がしやすい状態にするには、
以下の入力をする。

\begin{lstlisting}[style=plain]
Proof.
  move=> i1 i2 i3 vs cs.
  evalpartial evalseqc; subst_evars; simpl.
\end{lstlisting}

すると、以下の出力が得られる。

\begin{lstlisting}[style=plain]
1 subgoals, subgoal 1 (ID 42)
  
  i1 : inst
  i2 : inst
  i3 : inst
  vs : stack
  cs : stack
  ============================
   ([:: i3, i2, i1 & vs],
   [:: instquote, instswap, instquote, instcons, instswap,
       instquote, instcons, instexec
     & cs]) |=>* ([:: i1, i2, i3 & vs], cs)
\end{lstlisting}

継続スタックに具体的な命令が並んでいるので、これを順番に実行する。

\begin{lstlisting}[style=plain]
  evalpartial evalquote.
  evalpartial evalswap.
  evalpartial evalquote.
  evalpartial evalcons.
  evalpartial evalswap.
  evalpartial evalquote.
  evalpartial evalcons.
  evalpartial evalexec.
\end{lstlisting}

すると、以下の出力が得られる。

\begin{lstlisting}[style=plain]
1 subgoals, subgoal 1 (ID 73)
  
  i1 : inst
  i2 : inst
  i3 : inst
  vs : stack
  cs : stack
  ============================
   (vs,
   instpair (instpair (instpush i3) (instpush i2))
     (instpush i1) :: cs) |=>* ([:: i1, i2, i3 & vs], cs)
\end{lstlisting}

継続スタックの先頭に$i_3$、$i_2$、$i_1$をこの順に積む命令があることが分かるので、これを実行する。

\begin{lstlisting}[style=plain]
  do 2 evalpartial evalpair.
  do 3 evalpartial evalpush.
  apply evalrtc_refl.
\end{lstlisting}

すると、\texttt{No more subgoals.}と出力される。これは証明すべき命題が残っていないことを表しているの
で、以下の入力をして、証明を検査させる。

\begin{lstlisting}[style=plain]
Qed.
\end{lstlisting}

これで、目的の性質が証明できた。しかし、証明のほとんどの部分は継続スタックの先頭を見れば分かる程度の
ことしか書いてない上に、証明の対象となっているプログラムと対応する並びまで含まれている。これは冗長な
ので、証明を簡潔に記述する仕組みを開発した。新しい方法では、以下のように書ける。

\begin{lstlisting}[style=plain]
Proof.
  move=> i1 i2 i3 vs cs.
  evalauto.
Qed.
\end{lstlisting}



\section{ライブラリ}



\section{おわりに}



\end{document}
