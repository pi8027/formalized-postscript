\documentclass[cjk, 14pt]{beamer}

\usepackage{listings}

\usetheme{Copenhagen}
\usecolortheme{seahorse}
\useinnertheme{rounded}
\useoutertheme{shadow}

\setbeamercovered{transparent}

\title{\Coq{}で\\スタック指向プログラミング}
\author{坂口和彦 (@pi8027)}
\institute{筑波大学 情報学群 情報科学類 B2}
\date{2012/09/02}

\newcommand{\Coq}{{\scshape{}Coq}}
\newcommand{\Ltac}{\mbox{\emph{$\cal L$}tac}}

\begin{document}

\begin{frame}[plain]

 \maketitle

\end{frame}

\begin{frame}{自己紹介}

  \begin{description}
    \item [名前] 坂口和彦
    \item [好きな言語] \Coq, Agda2, PostScript, Haskell
    \item [GitHub] http://github.com/pi8027
  \end{description}

\end{frame}

\begin{frame}{目的}

  \begin{itemize}
    \item PostScriptプログラミングにはパズルのような楽しさがある。
    \item でも、PostScriptのプログラムは検証しづらい。
    \item $\rightarrow$ \, 証明を付けられる形で似た意味論を持つ言語を実装したい。
  \end{itemize}

\end{frame}

\begin{frame}{目的}

  \begin{itemize}
    \item PostScriptのプログラムを見ても、前提となっているスタックの状態が見えない。
    \item $\rightarrow$ \, スタックの状態を見ながらプログラムを書きたい。
  \end{itemize}

\end{frame}

\begin{frame}{実現できたこと}

  \begin{itemize}
    \item 8命令から成るPostScriptのサブセットを\Coq{}で定義した。
    \item 定義した言語が持つ良い性質を証明した。
    \item 自動実行器を\Ltac{}で実装した。
    \begin{itemize}
      \item \Ltac{}は\Coq{}のタクティク記述言語。
      \item 自動実行器は正しいルールを適用して変形するという作業をしているので、自動証明器でもある。
        (プログラミング言語の基礎概念(CoPL)の演習問題をいくつか解いてみるとイメージが掴みやすい)
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}{実現できたこと}

  \begin{itemize}
    \item ブール値や自然数の仕様とその上での演算を定義し、それらの正しさを証明した。
    \begin{itemize}
      \item 最も複雑なものは剰余付き除法。
    \end{itemize}
    \item プログラムをPostScriptに変換し、GhostScriptで実行できた。
    \item 目的の計算が存在することを自然に証明し、証明から具体的な計算を取り出せた。
  \end{itemize}

\end{frame}

\begin{frame}{方針}

  \begin{itemize}
    \item 最低限の命令しか用意しない。
    \item 計算の状態を2本の命令を要素とするスタックの組で表す。
    \begin{itemize}
      \item それぞれ、値のスタックと継続スタックを表す。
    \end{itemize}
    \item 計算は、環境上の二項関係として表す。
  \end{itemize}

\end{frame}

\begin{frame}[fragile]{言語の定義}

\small
\begin{verbatim}
Inductive inst : Set := ...
Definition stack : Set := list inst.
Definition environment : Set :=
  (stack * stack)%type.

Inductive eval : relation environment := ...
Definition evalrtc : relation environment :=
  clos_refl_trans_1n environment eval.

Infix "|=>" :=
  eval (at level 50, no associativity).
Infix "|=>*" :=
  evalrtc (at level 50, no associativity).
\end{verbatim}

\end{frame}

\begin{frame}{言語の定義}

  \begin{description}
    \item[\texttt{instpop}] 値のスタックの先頭を捨てる。
    \item[\texttt{instcopy}] 値のスタックの先頭を複製する。
    \item[\texttt{instswap}] 値のスタックの先頭の2つの命令を入れ替える。
    \item[\texttt{instcons}] 値のスタックの先頭の2つの命令を\texttt{instpair}で包む。
    \item[\texttt{instquote}] 値のスタックの先頭を\texttt{instpair}で包む。
    \item[\texttt{instexec}] 値のスタックの先頭を取り出し継続のスタックに積む。
    \item[\texttt{instpush} \, $i_1$] $i_1$を値のスタックに積む。
    \item[\texttt{instpair} \, $i_1$ \, $i_2$] $i_1$と$i_2$を継続のスタックに積む。
  \end{description}

\end{frame}

\begin{frame}{自動実行による証明}

  \begin{itemize}
    \item プログラムを書いてから証明を付けようとすると、
    \begin{itemize}
      \item 継続を見れば明らかなことを書かなければいけない。
      \item プログラムと証明がほとんど同じような構造を持っているので無駄が多い。
    \end{itemize}
    \item 任意の環境$e_1$に対する次の状態は一意に定まり、かつ存在するかしないかは決定可能。
    \item 自動実行によって証明を進めてしまっても問題は無い。
  \end{itemize}

\end{frame}

\begin{frame}{自動実行による証明 - 例}

\end{frame}

\begin{frame}{ブール値を作る}

  \begin{itemize}
    \item nopと同じ振舞いをするのがfalse。
    \item swapと同じ振舞いをするのがtrue。
    \item xorを取るにはconsすれば良い。ifも問題無く書ける。
  \end{itemize}

\end{frame}

\begin{frame}{自然数を作る}

  \begin{itemize}
    \item 任意の自然数$n$(0を含む)を表す命令$i_n$は、値のスタックの先頭の命令を継続スタックの先頭に$n$個複製する。
  \end{itemize}

\end{frame}

\begin{frame}{型を作る上で注意すべきこと}

  \begin{itemize}
    \item ブール値や自然数の定義のように、命令の振舞いによって値としての意味を与えるのは良い方法だが……
    \item もし仮にその型を持つ任意の値を表す命令が存在してしまうと、妥当な型の定義になっているとは言えない。
    \item 命令として同じなら表している値も同じであることを証明しなければいけない。
    \begin{itemize}
      \item (証明できるけどあまり綺麗にできていない)
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}{作れた計算}

  \begin{itemize}
    \item ブール型
    \begin{itemize}
      \item 否定
      \item if
      \item xor
    \end{itemize}
    \item 自然数
    \begin{itemize}
      \item 後者関数
      \item 加算
      \item 乗算
      \item 偶奇判定
      \item 前者関数
      \item 減算
      \item 剰余付き除算
    \end{itemize}
  \end{itemize}

\end{frame}

\begin{frame}{証明からプログラムを作る}

  \begin{itemize}
    \item プログラムを書いてから証明を書くには、まずプログラムを書かなければいけない。
    \item プログラムだけ書いていても計算の状態が全く見えない。
    \item 証明書いてるとスタックの状態が見えるので、証明書くのとプログラム書くのを行き来することに……。
    \item $\rightarrow$ \, 目的のプログラムが存在することを自然に証明できて、そこからプログラムを取り出せれば解決。
  \end{itemize}

\end{frame}

\begin{frame}{}

\end{frame}

\end{document}
